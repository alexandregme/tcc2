/**

	--
	Class: Coordinates Handler
	--

	--
	Author: Jaime Daniel Corrêa Mendes
	[a.k.a] ~LordShark
	--

	--
	Requires: jQuery 1.10.2, proj4
	--
	
	--
	Comments:
		Version 0.1. Works just with POINT and conversions
		Version 0.2. Works with features and conversion
		Version 0.3. Implement of 'set' function
		Version 0.4. Add callback to every function
		Version 0.41. Grouping field and label geo-input
		Version 0.42. Add class configuration
		Version 0.43. Geo Inputs are numbers! And added tabindexes...
	--

	--
	Public variables and methods:
		+ element
		+ datum
		+ clear()
	--

	--
	Sample Usage:

	
	--

*/

;(function (__window) {

	/**
	 * Coordinates
	 * Constructor Object
	 */
	Coordinates = function (__container, __feature, __startCallback, __css) {
	
		// ---- Dependencies
		if (!__feature) {
			throw new Error('Undefined Feature!');
		}
		
		if (!jQuery) {
			throw new Error('jQuery is not defined!');
		}
		
		if (!proj4) {
			throw new Error('Proj4JS is not defined!');
		}

		if ((__startCallback) && (!(__startCallback instanceof Function))) {
			throw new Error('Callback for Initialize should be a Function!');
		}
		
		proj4.defs('EPSG:4326', "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ");
		proj4.defs('EPSG:4674', "+proj=longlat +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +no_defs "); 
		proj4.defs('EPSG:32722', "+proj=utm +zone=22 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ");
		proj4.defs('EPSG:32723', "+proj=utm +zone=23 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ");
		proj4.defs('EPSG:32724', "+proj=utm +zone=24 +south +ellps=WGS84 +datum=WGS84 +units=m +no_defs ");
		proj4.defs('EPSG:31982', "+proj=utm +zone=22 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ");
		proj4.defs('EPSG:31983', "+proj=utm +zone=23 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ");
		proj4.defs('EPSG:31984', "+proj=utm +zone=24 +south +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs ");
		
		var _element = $('#' + __container);
		
		if (!_element) {
			throw new Error('The target element does not exist.');
		}
		
		var _self = this;
	
		// ---- Attributes
		
		/**
		 * Y or Latitude values
		 */
		this.y = [];
		
		/**
		 * X or Longitude values
		 */
		this.x = [];
		
		/**
		 * Selected Coordinates System
		 */
		this.selectedSystem = null;
		
		/**
		 * Selected Datum
		 */
		this.selectedDatum = null;
		
		/**
		 * Selected Feature
		 */
		this.selectedFeature = null;
		
		/**
		 * Tab Index
		 */
		this.tabindex = 0;
	
		/**
		 * HTML Element that holds the inputs
		 * Container: the element that holds everything
		 * System: holds the radio buttons for coordinates system
		 * Datum: holds the combo for select a datum
		 * Input: holds X and Y field(s)
		 * Extra: holds extra information like radius, area...
		 */
		this.element = {
			'container': null,
			'system': null,
			'datum': null,
			'input': null,
			'extra': null
		};
		
		/**
		 * The Coordinates themselves
		 * This is a GeoJSON of only one Feature
		 */
		this.datum = {
			'type': null,
			'coordinates': [],
			'properties': null,
			'crs': {
				'type': null,
				'properties': null
			}
		};
		
		/**
		 * Classes of the inputs
		 */
		this.css = (((__css ) && (__css instanceof Object)) ? _css : {
			'system_container': 'coordinates_system_container',
			'input': 'coordinates_input',
			'datum_container': 'coordinates_datum_container',
			'input_container': 'coordinates_input_container',
			'extra_container': 'coordinates_extra_container',
			'system': 'coordinates_system',
			'label_append': 'coordinates_label_append',
			'label_prepend': 'coordinates_label_prepend',
			'field_container': 'coordinates_field_container'
		});
		
		/**
		 * Setup all input format of coordinates
		 * and their datums
		 */
		this.configuration = [
			{
				'label': 'Coordenadas Geodésicas',
				'value': 'CG',
				'input': [
					{
						'value': 'GD',
						'label': 'Grau Decimal',
						'fields': [
							{
								'label': 'Latitude',
								'mask': /-?\d{2}(.\d{1,9})?/,
								'element': 'input',
								'properties': {
									'type': 'number',
									'id': 'y',
									'class': _self.css['input']
								}
							},
							{
								'label': 'Longitude',
								'mask': /-?\d{2}(.\d{1,9})?/,
								'element': 'input',
								'properties': {
									'type': 'number',
									'id': 'x',
									'class': _self.css['input']
								}
							}
						
						]
					},
					{
						'value': 'GMS',
						'label': 'Grau Minuto Segundo',
						'fields': [
							{
								'label': 'Latitude',
								'mask': /-?(\d{2})º(\d{2})'(\d{2}(.\d{1,9})?)''/,
								'element': 'input',
								'properties': {
									'type': 'text',
									'id': 'y',
									'class': _self.css['input']
								}
							},
							{
								'label': 'Longitude',
								'mask': /-?(\d{2})º(\d{2})'(\d{2}(.\d{1,9})?)''/,
								'element': 'input',
								'properties': {
									'type': 'text',
									'id': 'x',
									'class': _self.css['input']
						
								}
							}
						]
					}
				],
				'datums': [
					{
						'label': 'WGS 84',
						'srid': 'EPSG:4326',
						'fuse': null,
						'main': true
					},
					{
						'label': 'SIRGAS 2000',
						'srid': 'EPSG:4674',
						'fuse': null,
						'main': false
					}
				]
			},
			{
				'label': 'Coordenadas Projetadas',
				'value': 'CP',
				'input': [
					{
						'value': 'UTM',
						'label': 'Universal Transversa de Mercator',
						'fields': [
							{
								'label': 'Y',
								'mask': /\d{1,10}(.\d{1,10})?/,
								'element': 'input',
								'properties': {
									'type': 'number',
									'id': 'y',
									'class': _self.css['input']
								}
							},
							{
								'label': 'X',
								'mask': /\d{1,10}(.\d{1,10})?/,
								'element': 'input',
								'properties': {
									'type': 'number',
									'id': 'x',
									'class': _self.css['input']
								}
							}
						]
					}
				],
				'datums': [
					{
						'label': 'WGS 84 [22S]',
						'srid': 'EPSG:32722',
						'fuse': '22S',
						'main': true
					},
					{
						'label': 'WGS 84 [23S]',
						'srid': 'EPSG:32723',
						'fuse': '23S',
						'main': false
					},
					{
						'label': 'WGS 84 [24S]',
						'srid': 'EPSG:32724',
						'fuse': '24S',
						'main': false
					},
					{
						'label': 'SIRGAS 2000 [22S]',
						'srid': 'EPSG:31982',
						'fuse': '22S',
						'main': false
					},
					{
						'label': 'SIRGAS 2000 [23S]',
						'srid': 'EPSG:31983',
						'fuse': '23S',
						'main': false
					},
					{
						'label': 'SIRGAS 2000 [24S]',
						'srid': 'EPSG:31984',
						'fuse': '24S',
						'main': false
					}
				]
			}
		];
		
		/**
		 * Setup for the features that are possible 
		 * to use with coordinates
		 * geographicsInputs = array for the number os pair xy
		 * figure = data:image/png
		 * extra = for extra container [set of fields]
		 */
		this.features = {
		
			'point': {
				'geographicInputs': [
					{
						'label': 'Ponto',
						'visible': false
					}
				],
				'figure': '',
				'feature': 'Point',
				'extra': null
			},
			'radius': {
				'geographicInputs': [
					{
						'label': 'Centro',
						'visible': true
					}
				],
				'figure': '',
				'feature': 'Point',
				'extra': [
					{
						'label': 'Raio',
						'mask': /\d{1,5}(.\d{1,5})?/,
						'geojson': 'raio',
						'element': 'input',
						'properties': {
							'type': 'number',
							'id': 'tiRadius',
							'class': _self.css['input']
						}
					}
				]
			},
			'box': {
				'geographicInputs': [
					{
						'label': 'Superior',
						'visible': true
					},
					{
						'label': 'Inferior',
						'visible': true
					}
				],
				'figure': '',
				'feature': 'Polygon',
				'extra': [
					{
						'label': 'Área',
						'mask': /\d{1,5}(.\d{1,5})?/,
						'geojson': 'area',
						'element': 'input',
						'properties': {
							'type': 'number',
							'id': 'tiArea',
							'class': _self.css['input']
						}
					}
				]
			}
		
		};
		
		if (!this.features.hasOwnProperty(__feature)) {
			throw new Error('Unknowm feature.');
		}
		
		this.selectedFeature = __feature;
		
		// ---- Methods
		
		/**
		 * Adds a Datum
		 */
		this.addDatum = function addDatum (__datum) {
		
		};
		
		/**
		 * Removes a Datum
		 */
		this.deleteDatum = function deleteDatum (__srid) {
		
		};
		
		/**
		 * Generic Callback invoker
		 */
		this.callback = function () {
			
			var _function = _self[_self.callback.caller.name].callback;
			
			if (_function instanceof Function) {
				_function();
			}
			
		}
		
		/**
		 * Initialize
		 */
		this.start = function start (__startCallback) {
		
			// --- HTML structure
			
			_self.element.container = _element;
			_self.element.container.empty();
			
			_self.element.system = $('<div />', {
				'id': 'coordinatesSystemContainer',
				'class': _self.css['system_container']
			});
			
			_self.element.datum = $('<div />', {
				'id': 'coordinatesDatumContainer',
				'class': _self.css['datum_container']
			});
			
			_self.element.input = $('<div />', {
				'id': 'coordinatesInputContainer',
				'class': _self.css['input_container']
			});
			
			_self.element.extra = $('<div />', {
				'id': 'coordinatesExtraContainer',
				'class': _self.css['extra_container']
			});
			
			_self.element.container.append(_self.element.system, _self.element.datum, _self.element.input, _self.element.extra);
			
			// --- RADIOS (Coordinates System)
			
			var _systems = [[0,0], [0,1], [1,0]];
				
			for (var i = 0; i < _systems.length; i++) {
				
				var _input = _self.configuration[_systems[i][0]].input[_systems[i][1]];
				
				var _radio = $('<input />', {
					'id': 'rbCoordinateSystem_' + __container + i,
					'type': 'radio',
					'name': 'coordinates_system_' + __container,
					'class': _self.css['system'],
					'title': _input.label,
					'value': _input.value,
					'change': function (__csIndex, __iIndex) {
						return function onChangeCoordinatesSystem () {
							_self.onChangeCoordinatesSystem(this, __csIndex, __iIndex)
						}
					}(_systems[i][0], _systems[i][1])
				});
				
				var _label = $('<label />', {
					'id': 'lbCoordinateSystem_' + __container + i,
					'for': 'rbCoordinateSystem_' + __container + i,
					'text': _input.label,
					'class': _self.css['label_append']
				});
				
				_self.element.system.append(_radio, _label);
				
			}
			
			// --- EXTRAS
			// TODO [melhorar a versão para "qualquer" tipo de componente]
			
			var _extra = _self.features[_self.selectedFeature].extra;
			
			if (_extra && _extra.length > 0) {
			
				for (var e = 0; e < _extra.length; e++) {
				
					var _input = _extra[e];
				
					var _label = $('<label />', {
						'for': _input.properties.id,
						'text': _input.label,
						'class': _self.css['label_prepend']
					});
				
					var _field = $('<' + _input.element + ' />', _input.properties);
					
					_self.element.extra.append(_label, _field);

				}
			
			}
			
			if (__startCallback) {
				_self.start.callback = __startCallback;
				_self.callback();
			}
			
		};
		
		/**
		 * Reset the datum property
		 */
		this.clear = function clear () {
		
			this.x = [];
			this.y = [];
			
			this.selectedSystem = null;
			this.selectedDatum = null;
			
			_self.element.input.empty();
			_self.element.datum.empty();
			
			this.datum = {
				'type': null,
				'coordinates': [],
				'properties': null,
				'crs': {
					'type': null,
					'properties': null
				}
			}
			
			_self.callback();
		
		};
		
		/**
		 * Return a GeoJSON
		 */
		this.get = function get () {
		
			if (_self.x.length == 0) {
				return null;
			}
			
			_self.datum.type = _self.features[_self.selectedFeature].feature;
			
			for (var p = 0; p < _self.x.length; p++) {
				_self.datum.coordinates.push([_self.x[p], _self.y[p]]);
			}
			
			_self.datum.crs.type = 'EPSG';
			_self.datum.crs.properties = {
				'code': proj4.defs[_self.selectedDatum.srid].EPSG
			};
			
			// Extra
			var _extra = _self.features[_self.selectedFeature].extra;
			
			if (_extra && _extra.length > 0) {
			
				_self.datum.properties = new Object();
				
				for (var e = 0; e < _extra.length; e++) {
					_self.datum.properties[_extra[e].geojson] = $('#' + _extra[e].properties.id).val();
				}
			
			}
			
			return _self.datum;
		
		};
		
		/**
		 * Sets values for a specified feature
		 */
		this.set = function set (__feature, __system, __srid, __points, __extra) {
		
			if (__system != 'UTM' && __system != 'GMS' && __system != 'GD') {
				throw new Error('Undefined coordinates system!');
			}
			
			var _csIndex = (__system == 'GMS' || __system == 'GD') ? 0 : 1;
			var _iIndex = (__system == 'UTM') ? 0 : (__system == 'GMS' ? 1 : 0);
			
			if ((!__feature) && (!_self.features.hasOwnProperty(__feature))) {
				throw new Error('Undefined Feature!');
			}
			
			var _feature = _self.features[__feature];
			
			if (!(__points instanceof Array) && (_feature.geographicInputs.length != __points.length)) {
				throw new Error('Points must be an array with the same size of its feature!');
			}
			
			if (!__srid) {
				throw new Error('SRID cannot be null!');
			}
			
			var _datums = [].concat(_self.configuration[0].datums, _self.configuration[1].datums);
			var _datum = null;
			
			for (var d = 0; d < _datums.length; d++) {
			
				if (__srid == _datums[d].srid) {
					_datum = _datums[d];
					break;
				}
			
			}
			
			if (!_datum) {
				throw new Error('Undefined Datum!');
			}
			
			for (var p = 0; p < __points.length; p++) {
				
				_self.x[p] = __points[p][0].toString();
				_self.y[p] = __points[p][1].toString();
			
			}
			
			_self.selectedSystem = null;
			
			_self.element.system.find('input[type="radio"]').each(function (__index, __radio) {
			
				if (__radio.value == __system) {
					__radio.checked = true;
				} else {
					__radio.checked = false;
				}
			
			});

			_self.onChangeCoordinatesSystem({'value': __system}, _csIndex, _iIndex, _datum);
			
			if (_feature.extra) {
			
				if (!__extra) {
					throw new Error('You did not specified the extra properties!');
				} else {
				
					for (var e = 0; e < _feature.extra.length; e++) {
						$('#' + _feature.extra[e].properties.id).val(__extra[_feature.extra[e].geojson]);
					}
				
				}
			
			}
			
			_self.callback();
	
		}
		
		/**
		 * Return a WKT
		 * If __system or __fuse were not specified
		 * the wkt will hold the selected Datum. Otherwise
		 * it will be converted
		 */
		this.getWkt = function getWkt (__system, __fuse) {
		
			if (_self.x.length == 0) {
				return null;
			}
			
			var _wkt = _self.features[_self.selectedFeature].feature.toUpperCase() + ' ({{points}})';
			
			if (_self.selectedSystem == 'GMS') {
				_self.GMSToGD();
			}
			
			if (_self.x.length == 1) {
				_wkt = _wkt.replace(/{{points}}/g, _self.x[0] + ' ' + _self.y[0]);
			} else {
			
				var _points = new Array();
				
				for (var p = 0; p < _self.x.length; p++) {
					_points.push('(' + _self.x[p] + ' ' + _self.y[p] + ')')
				}
			
				_wkt = _wkt.replace(/{{points}}/g, _points.join(' '));
			
			}
			
			if (_self.selectedSystem == 'GMS') {
				_self.GDToGMS();
			}
			
			return _wkt;			
		
		};
		
		/**
		 * Change the selected Datum
		 */
		this.onChangeDatum = function onChangeDatum (__input) {
			
			var _oldDatum = _self.selectedDatum;

			_self.selectedDatum = _self.configuration[$(__input).attr('data-index')].datums[__input.selectedIndex];
			
			if (_self.x.length == 0 && _self.y.length == 0) {
				return;
			}
			
			var _fromProjection = new proj4.Proj(_oldDatum.srid);
			var _toProjection = new proj4.Proj(_self.selectedDatum.srid);
			
			if (_self.selectedSystem == 'GMS') {
				_self.GMSToGD();
			}
			
			// Convert for all points
			for (var i = 0; i < _self.features[_self.selectedFeature].geographicInputs.length; i++) {
			
				var _point = new proj4.Point(parseFloat(_self.x[i]), parseFloat(_self.y[i]));
			
				proj4.transform(_fromProjection, _toProjection, _point);
			
				if (_self.selectedSystem == 'GMS') {
					_self.GDToGMS();
				} else {
					_self.x[i] = _point.x.toString();
					_self.y[i] = _point.y.toString();
				}
			
				$('#x' + i).val(_self.x[i]);
				$('#y' + i).val(_self.y[i]);
			
			}
			
			_self.callback();
			
		};
		
		/**
		 * Change the selected coordinates system
		 */
		this.onChangeCoordinatesSystem = function onChangeCoordinatesSystem (__input, __csIndex, __iIndex, __datum) {
			
			// Tabindex
			_self.tabindex = 0;
			
			// Coordinates Conversion
			var _oldSelectedSystem = _self.selectedSystem;
			var _newSelectedSystem = __input.value;
			var _oldSelectedDatum = _self.selectedDatum;
			
			_self.selectedSystem = __input.value;
			
			_self.element.input.empty();
			_self.element.datum.empty();
			
			// Datum ----
			var _label = $('<label />', {
				'id': 'lbDatum',
				'for': 'cbDatum',
				'text': 'Datum',
				'class': _self.css['label_prepend']
			});
			
			var _select = $('<select />', {
				'id': 'cbDatum',
				'name': 'datum',
				'class': _self.css['input'],
				'tabindex': ++_self.tabindex,
				'data-index': __csIndex,
				'change': function () {
					_self.onChangeDatum(this);
				}
			});
				
			var _datums = _self.configuration[__csIndex].datums;
			
			for (var d = 0; d < _datums.length; d++) {
				
				var _options = {
					'value': _datums[d].srid,
					'html': _datums[d].label
				}
				
				// Already selected a coordinate system...
				if (_oldSelectedSystem) {
					
					switch (_oldSelectedSystem) {
					
						case 'GMS':
						case 'GD':
						
							switch (_newSelectedSystem) {
							
								case 'UTM':
								
									if (_datums[d].main === true) {
										_options['selected'] = 'selected';
										_self.selectedDatum = _datums[d];	
									}
								
								break;
								
								default:
								
									if (_datums[d].srid == _oldSelectedDatum.srid) {
										_options['selected'] = 'selected';
										_self.selectedDatum = _datums[d];
									}
								
								break;
							
							}
						
						break;
						
						case 'UTM':
						
							switch (_newSelectedSystem) {
							
								case 'UTM':
								
									if (_datums[d].srid == _oldSelectedDatum.srid) {
										_options['selected'] = 'selected';
										_self.selectedDatum = _datums[d];
									}
									
								break;
								
								default:
								
									if (_datums[d].main === true) {
										_options['selected'] = 'selected';
										_self.selectedDatum = _datums[d];	
									}
								
								break;
							
							}
						
						break;
					
					}
					
				}
				
				// Never selected a coordinate system...
				if (!_oldSelectedSystem) {
					
					if (__datum != null) {
					
						if (__datum.srid == _datums[d].srid) {
							_options['selected'] = 'selected';
							_self.selectedDatum = _datums[d];
						}
					
					} else {
					
						if (_datums[d].main === true) {
							_options['selected'] = 'selected';
							_self.selectedDatum = _datums[d];
						}
					
					}
					
				}
				
				_select.append($('<option />', _options));
				
			}
			
			_self.element.datum.append(_label, _select);
			// Datum ----
			
			// Coordinates
			_self.convertCoordinates(_oldSelectedSystem, _newSelectedSystem, _oldSelectedDatum, _self.selectedDatum);

			// Inputs ----
			var _geographicsInputs = _self.features[_self.selectedFeature].geographicInputs;
			
			for (var f = 0; f < _geographicsInputs.length; f++) {
			
				var _geoInput = _geographicsInputs[f];
				
				var _inputs = _self.configuration[__csIndex].input[__iIndex].fields;
			
				for (var i = 0; i < _inputs.length; i++) {
					
					var _input = $.extend(true, {}, _inputs[i]);
					
					var _xy = _input.properties.id;
					
					var _label = $('<label />', {
						'for': _input.properties.id + f.toString(),
						'text': _input.label + (_geoInput.visible ? ' (' + _geoInput.label + ')' : ''),
						'class': _self.css['label_prepend']
					});
					
					_input.properties.title = _input.label;
					_input.properties.id += f.toString();
					_input.properties.tabindex = ++_self.tabindex;
					
					var _field = $('<' + _input.element + ' />', _input.properties);
					
					_field.val(_self[_xy][f]);
					
					_field.keyup((function (__xy, __index) {
						return function () {
							_self[__xy][__index] = $(this).val()
						}
					})(_xy, f));
				
					var _container = $('<div />', {
						'class': _self.css['field_container'] + ' coordinates_group_' + _input.properties.id + f.toString()
					});
					
					_container.append(_label, _field);
					
					_self.element.input.append(_container);
					
				}
			
			}
			// Inputs ----
			
			_self.callback();
			
		};
		
		/**
		 * Checks for the source system format and calls the appropriated function
		 */
		this.convertCoordinates = function convertCoordinates (__fromCS, __toCS, __fromDatum, __toDatum) {
		
			if (__fromCS == null) {
				return;
			}
			
			if (_self.x.length == 0 && _self.y.length == 0) {
				return;
			}
			
			if (__fromCS == 'GD' && __toCS == 'GMS') {
				_self.GDToGMS();
			} else if (__fromCS == 'GMS' && __toCS == 'GD') {
				_self.GMSToGD();
			} else if (__fromCS == 'GD' && __toCS == 'UTM') {
				_self.GDToUTM(__fromDatum, __toDatum);
			} else if (__fromCS == 'UTM' && __toCS == 'GD') {
				_self.UTMToGD(__fromDatum, __toDatum);
			} else if (__fromCS == 'GMS' && __toCS == 'UTM') {
				_self.GMSToUTM(__fromDatum, __toDatum);
			} else if (__fromCS == 'UTM' && __toCS == 'GMS') {
				_self.UTMToGMS(__fromDatum, __toDatum);
			} else {
				throw new Error('Unexpected coordinates system');
			}
			
			_self.callback();
		
		};
		
		/**
		 * Converts Decimal Degrees to Degrees, Minutes and Seconds
		 */
		this.GDToGMS = function GDToGMS () {
		
			for (var i = 0; i < _self.features[_self.selectedFeature].geographicInputs.length; i++) {
			
				var _y = parseFloat(_self.y[i]);
				var _x = parseFloat(_self.x[i]);
			
				var _latA = Math.abs(Math.round(_y * 1000000.));
				var _lonA = Math.abs(Math.round(_x * 1000000.));
						
				var _signLat = (_self.y[i].indexOf('-') >= 0) ? -1 : 1;
				var _signLon = (_self.x[i].indexOf('-') >= 0) ? -1 : 1;
						
				_self.y[i] = (_gLat = Math.floor(_latA / 1000000) * _signLat) + String.fromCharCode(186);
				_self.y[i] += (Math.floor(((_latA / 1000000) - Math.floor(_latA / 1000000)) * 60)) + "'";
				_self.y[i] += ((Math.floor(((((_latA / 1000000) - Math.floor(_latA / 1000000)) * 60) - Math.floor(((_latA / 1000000) - Math.floor(_latA / 1000000)) * 60)) * 100000) * 60 / 100000)) + "''";
					
				_self.x[i] = (Math.floor(_lonA / 1000000) * _signLon) + String.fromCharCode(186);
				_self.x[i] += (Math.floor(((_lonA/1000000) - Math.floor(_lonA / 1000000)) * 60)) + "'";
				_self.x[i] += ((Math.floor(((((_lonA / 1000000) - Math.floor(_lonA / 1000000)) * 60) - Math.floor(((_lonA / 1000000) - Math.floor(_lonA / 1000000)) * 60)) * 100000) *60 / 100000)) + "''";
			
			}
			
			_self.callback();
		
		};

		/**
		 * Converts Degrees, Minutes and Seconds to Decimal Degrees
		 */
		this.GMSToGD = function GMSToGD () {
		
			var _regex = new RegExp("^(\\-?\\d+)" + String.fromCharCode(186) + "(\\d+)'(\\d+(\\.\\d+)?)''$");
			
			for (var i = 0; i < _self.features[_self.selectedFeature].geographicInputs.length; i++) {
			
				var _y = _self.y[i].match(_regex);
				var _x = _self.x[i].match(_regex);
				
				var _signLat = (_self.y[i].indexOf('-') >= 0) ? -1 : 1;
				var _signLon = (_self.x[i].indexOf('-') >= 0) ? -1 : 1;
				
				var gAy = Math.abs(Math.round(parseFloat(_y[1].replace('-', '')) * 1000000.));
				var mAy = Math.abs(Math.round(parseFloat(_y[2]) * 1000000.));
				var sAy = Math.abs(Math.round(parseFloat(_y[3]) * 1000000.));
				
				var gAx = Math.abs(Math.round(parseFloat(_x[1].replace('-', '')) * 1000000.));
				var mAx = Math.abs(Math.round(parseFloat(_x[2]) * 1000000.));
				var sAx = Math.abs(Math.round(parseFloat(_x[3]) * 1000000.));
				
				_self.y[i] = (Math.round(gAy + (mAy / 60.) + (sAy / 3600.)) * _signLat / 1000000).toString();
				_self.x[i] = (Math.round(gAx + (mAx / 60.) + (sAx / 3600.)) * _signLon / 1000000).toString();
			
			}
			
			_self.callback();
		
		};

		/**
		 * Converts Decimal Degrees to Projected Coordinates System
		 */
		this.GDToUTM = function GDToUTM (__fromDatum, __toDatum) {
			
			var _fromProjection = new proj4.Proj(__fromDatum.srid);
			var _toProjection = new proj4.Proj(__toDatum.srid);
			
			for (var i = 0; i < _self.features[_self.selectedFeature].geographicInputs.length; i++) {
			
				var _point = new proj4.Point(parseFloat(_self.x[i]), parseFloat(_self.y[i]));
				
				proj4.transform(_fromProjection, _toProjection, _point);      

				_self.x[i] = _point.x.toString();
				_self.y[i] = _point.y.toString();
			
			}
			
			_self.callback();
			
		};

        /**
		 * Converts Projected Coordinates System Decimal Degrees
		 */
		this.UTMToGD = function UTMToGD (__fromDatum, __toDatum) {
			
			var _fromProjection = new proj4.Proj(__fromDatum.srid);
			var _toProjection = new proj4.Proj(__toDatum.srid);
			
			for (var i = 0; i < _self.features[_self.selectedFeature].geographicInputs.length; i++) {
			
				var _point = new proj4.Point(parseFloat(_self.x[i]), parseFloat(_self.y[i]));
				
				proj4.transform(_fromProjection, _toProjection, _point);      

				_self.x[i] = _point.x.toString();
				_self.y[i] = _point.y.toString();
				
			}
			
			_self.callback();
			
		};

        /**
		 *
		 */
		this.GMSToUTM = function GMSToUTM (__fromDatum, __toDatum) {
			
			_self.GMSToGD();
			
			var _fromProjection = new proj4.Proj(__fromDatum.srid);
			var _toProjection = new proj4.Proj(__toDatum.srid);
			
			for (var i = 0; i < _self.features[_self.selectedFeature].geographicInputs.length; i++) {
			
				var _point = new proj4.Point(parseFloat(_self.x[i]), parseFloat(_self.y[i]));
				
				proj4.transform(_fromProjection, _toProjection, _point);      

				_self.x[i] = _point.x.toString();
				_self.y[i] = _point.y.toString();
			
			}
			
			_self.callback();
		
		};

		/**
		 *
		 */
		this.UTMToGMS = function UTMToGMS (__fromDatum, __toDatum) {
		
			var _fromProjection = new proj4.Proj(__fromDatum.srid);
			var _toProjection = new proj4.Proj(__toDatum.srid);
			
			for (var i = 0; i < _self.features[_self.selectedFeature].geographicInputs.length; i++) {
			
				var _point = new proj4.Point(parseFloat(_self.x[i]), parseFloat(_self.y[i]));
				
				proj4.transform(_fromProjection, _toProjection, _point);      

				_self.x[i] = _point.x.toString();
				_self.y[i] = _point.y.toString();
			
			}
			
			_self.GDToGMS();
			
			_self.callback();
		
		};
		
		// ---- Set undefined callbacks
		for (var _function in this) {
		
			var _f = this[_function];
		
			if (_f instanceof Function) {
				_f.callback = null;
			}
			
		}
		
		// ---- Run
		this.start(__startCallback);

	};

})(window);